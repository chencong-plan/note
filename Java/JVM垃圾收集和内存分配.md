[TOC]



### 运行时数据区

![运行时数据区](http://7xjtfr.com1.z0.glb.clouddn.com/41376821593549120.jpg)

1.  程序计数器（线程私有）

    >   当前线程所执行的字节码的行号指示器。

2.  栈（线程私有）

    >   每个方法执行时会创建一个栈帧用于存储局部变量等信息。

3.  本地方法栈（类似栈）

    >   为虚拟机使用到的`Native`方法服务

4.  堆（线程共享）

    >   存放对象实例，是垃圾收集器管理的主要区域

5.  方法区（线程共享）

    >   用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。（也被人称之为`永久代`），运行时常量池位于这个区域，用于存放编译期产生的各种字面量和符号引用。

### 垃圾回收

#### 回收的对象

>   堆中的对象

##### 可达性分析算法

从`GC Roots`出发，没有跟`GC Roots`引用链相连的对象可回收。

##### GC Roots选择

1.  栈中引用的对象。
2.  方法区（`永久代`）中引用的对象。
3.  本地方法栈中引用的对象。

##### 引用

1.  **强引用**：不会被回收
2.  **软引用**：内存不足时才会被回收
3.  **弱引用**：只能生存到下一次垃圾回收发生之前
4.  **虚引用**：被回收时能够收到一个系统通知。

#### 回收的方法

##### 标记清除算法

标记需要回收的对象，标记完成之后清除被标记对象。

**缺点 **：效率低，空间碎片

##### 复制算法

把内存空间分为两块，只是用其中的一块，满了之后把存活的对象复制到另一块，清除本块对象。

**缺点**：存活率大时，需要进行较多复制操作。

##### 标记整理算法

标记回收对象之后，把它们移动到一端，清除段边界的对象。

##### 分代收集算法

将堆分为两块

>   1.  **新生代**：使用复制算法，包括一个`Eden`空间和两个`Survivor`空间
>   2.  **老年代**：使用标记清除或标记整理算法

#### 垃圾回收器

![垃圾收集器](http://7xjtfr.com1.z0.glb.clouddn.com/20130925212623125.jpg)

1.  `Serial`：单线程收集器，工作时暂停其他工作线程。



