[TOC]



### 运行时数据区

![运行时数据区](http://7xjtfr.com1.z0.glb.clouddn.com/41376821593549120.jpg)

1.  程序计数器（线程私有）

    >   当前线程所执行的字节码的行号指示器。

2.  栈（线程私有）

    >   每个方法执行时会创建一个栈帧用于存储局部变量等信息。

3.  本地方法栈（类似栈）

    >   为虚拟机使用到的`Native`方法服务

4.  堆（线程共享）

    >   存放对象实例，是垃圾收集器管理的主要区域

5.  方法区（线程共享）

    >   用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。（也被人称之为`永久代`），运行时常量池位于这个区域，用于存放编译期产生的各种字面量和符号引用。

### 垃圾回收

#### 回收的对象

>   堆中的对象

##### 可达性分析算法

从`GC Roots`出发，没有跟`GC Roots`引用链相连的对象可回收。

##### GC Roots选择

1.  栈中引用的对象。
2.  方法区（`永久代`）中引用的对象。
3.  本地方法栈中引用的对象。

##### 引用

1.  **强引用**：不会被回收
2.  **软引用**：内存不足时才会被回收
3.  **弱引用**：只能生存到下一次垃圾回收发生之前
4.  **虚引用**：被回收时能够收到一个系统通知。

#### 回收的方法

##### 标记清除算法

标记需要回收的对象，标记完成之后清除被标记对象。

**缺点 **：效率低，空间碎片

##### 复制算法

把内存空间分为两块，只是用其中的一块，满了之后把存活的对象复制到另一块，清除本块对象。

**缺点**：存活率大时，需要进行较多复制操作。

##### 标记整理算法

标记回收对象之后，把它们移动到一端，清除段边界的对象。

##### 分代收集算法

将堆分为两块

>   1.  **新生代**：使用复制算法，包括一个`Eden`空间和两个`Survivor`空间
>   2.  **老年代**：使用标记清除或标记整理算法

#### 垃圾回收器

![垃圾收集器](http://7xjtfr.com1.z0.glb.clouddn.com/20130925212623125.jpg)

1.  `Serial`：单线程收集器，工作时暂停其他工作线程。常用语`client`模式，在新生代采用复制算法，在老生代使用标记-整理算法。

2.  `ParNew:Serial`多线程版本，并行收集器，主要用于新生代收集。与CMS收集器配合成为现在最常用的server收集器。

3.  `Parallel Scavenge`并行收集器，吞吐量（用户代码运行时间/用户代码运行时间+垃圾收集时间）优先。

4.  `Serial Old:Serial`老年代版本，单线程，使用`标记-整理`算法。

5.  `Parllel Old:Parallel Scavenge`的老年代版本。

6.  `CMS`:并发收集，低停顿，基于`标记-清除`算法。

    >   1.  初始标记：暂停工作线程，标记`GC Roots`能直接关联到对象。
    >   2.  并发标记：与工作线程并发，进行`GC Roots Tracing`
    >   3.  重新标记：暂停工作进程，修正并发标记过程中发生变动的对象。
    >   4.  并发清除

    缺点：

    >   1.  对`CPU`资源非常敏感
    >   2.  不能处理浮动垃圾（标记过程后出现的垃圾）
    >   3.  产生空间碎片

7.  G1 （Garbange First）

    >   1.  并行与并发
    >   2.  分代收集（概念上分代，实际的内存布局不再是新生代、老年代隔离）
    >   3.  空间整合（基于`标记整理`算法）
    >   4.  可预测的停顿
    >   5.  分`Region`收集，根据允许收集的时间，有限回收代价大的`Region`

    过程：

    >   1.  初始标记
    >   2.  并发标记
    >   3.  最终标记：并行
    >   4.  筛选标记：并行



---



### 内存分配

+   **新生代GC**：（Minor GC）发生在新生代的垃圾收集，速度较快。

+   **老年代**：（Major GC/Full GC）发生在老年代的垃圾收集，速度比较慢。

+   首先向`eden`区申请分配空间，如果空间够，就直接进行分配，否则进行一次`minor GC`

+   `Minor GC`首先会对`Eden`区的对象进行标记，标记出来存活的的对象。然后把存活的对象copy到`From`空间。（标记-复制）

    >   +   如果`From`空间足够，则回收`eden`区可回收的对象。
    >   +   如果`From`内存空间不够，则把`From`空间存活的对象复制到`To`区。
    >   +   如果`To`区的内存空间也不够的话，则把`To`区存活的对象复制到老年代。

+   如果老年代空间也不够的话，或者达到触发老年代垃圾回收的条件话，就出发一次`Full GC`。

#### Full GC触发条件

+   **System.gc()方法调用**

    >   此方法的调用时建议`JVM`进行`Full GC`，虽然只是建议而非一定，但是很多情况下它会触发`Full GC`,从而增加`Full GC`的频率，也增加了间歇性停顿的次数。建议在能不使用此方法时就不用。让虚拟机自己去管理内存，同时也可以通过`-XX:+ DisableExplicitGC来禁止RMI调用System.gc。`

+   **老年代空间不足**

    >   老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象。当然，如果执行了`Full GC`操作之后仍然空间不足，则会抛出` java.lang.OutOfMemoryError: Java heap space `，为了避免以上两种情况引起的`Full GC`，调优时候尽量做到让对象在`Minor GC`阶段被回收，让对象在新生代多存货一段时间、不要创建过大的对象或数组。

+   **永生区空间不足**

    >   `JVM`规范当中运行时数据区域中的方法区，在`HotSpot`虚拟机中又被习惯称为`永生代`或`永生区`，`Permanet Generation`中存放的是一些类的信息、常量、静态变量等数据；当系统中要加载的类、反射的类和调用的方法比较多，`Permantet Generation`可能被占座，在未配置为采用`CMS GC`的情况下还行`Full GC `。如果经过	`Full GC`仍然回收不了，那么`JVM`则会抛出如下异常：`java.lang.OutOfMemoryError: PermGen space `，为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。

+   **CMS GC时出现promotion failed和concurrent mode failure**

    >   对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能 会触发Full GC。 promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；concurrent mode failure是在 执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。 对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕 后很久才触发sweeping动作。对于这种状况，可通过设置`-XX: CMSMaxAbortablePrecleanTime=5`（单位为ms）来避免。

+   **统计得到的`Minor GC`晋升到旧生代的平均大小大于老年代的剩余时间**

    >   这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之 前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB， 则执行Full GC。 当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否 大于6MB，如小于，则触发对旧生代的回收。 除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过`- java - Dsun.rmi.dgc.client.gcInterval=3600000`来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

+   **堆中分配很大对象**

    >   所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。 为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 `-XX:CMSFullGCsBeforeCompaction`,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的。

#### 内存分配策略

1.  对象有限的`Eden`分配
2.  大对象直接进入老年代。
3.  长期存活的对象将进入老年代：对象年龄达到设置值。
4.  动态对象的年龄判断：如果`Surivivor`空间中相同年龄的所有对象的大小和大于`Surivivor`空间一半，大于登录该年龄的对象进入老年代。
5.  空间分配担保：发生`Minor GC`之前，虚拟机会检查老年代的可用空间是否大于新生代所有对象的空间，条件成立则`Minor GC`是是安全的。

#### 内存布局

![内存布局](http://7xjtfr.com1.z0.glb.clouddn.com/06524e23ef9136970be290e3732c0066_thumb.jpg)











