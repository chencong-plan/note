[TOC]



**2018-4-9 记录**

>   参考[Java总结摘要](https://www.cnblogs.com/java1024/p/7685400.html)

---



#### 1.ThreadLocal（线程变量副本）

Synchronized实现内存共享，`ThreadLocal`为每一个线程维护一个本地变量。

前者为`时间换空间` ,后者`空间换时间`，用于线程之间的数据隔离，为每一个使用该变量的 线程提供一个副本，每个线程都可以独立的改变自己的副本，而不会与其他线程的副本产生冲突 。

`ThreadLocal`当中维护了一个`Map`，用户存储每一个线程的变量副本，`Map`中元素的键为线程对象，值为对应线程的变量副本。

`ThreadLocal`在很多地方都用到了，比如`Spring`的`Request`作用域中的`bean`，事务管理，任务调度，`AOP`等模块都有出现。

比如，在`Spring`当中Bean声明成`Signleton`作用域，采用`ThreadLocal`进行封装，这样保证了有状态的`Bean `能够以`Singleton`的方法在多个线程当中正常工作了。

>   该类的具体使用，可以参考文章[深入研究java.lang.ThreadLocal类](http://blog.51cto.com/lavasoft/51926)



---



#### 2.Java内存模型

1.  **程序计数器**是一个数据结构，用于保证当前正在执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理时间来实现的。当然，为了保证线程切换之后能够恢复到正确的位置，每条线程都需要一个独立的程序计数器，并且各线程程序计数器互不影响，该区域为`线程私有`
2.   **Java虚拟机栈** 线程私有，与线程生命周期相同，用于存储局部变量表、操作栈、方法返回值。局部变量表存放着基本数据类型，还有对象引用。
3.   **本地方法栈 **跟虚拟机栈相似，但是它是为虚拟机使用到的`Native`方法服务
4.   **Java堆** 所有线程共享的一块内存区域，对象实例几乎都在这里分配内存。
5.  **方法区** 各个线程共享的区域，存储虚拟机加载的类信息，常量，静态变量，编译之后的代码
6.  **运行时常量池** 代表运行时每个`Class`文件中的常量表。包括：编译时的数字常量、方法或者域的引用。

>   关于`JVM`虚拟机详细可以看这里[Java中JVM虚拟机详解](https://blog.csdn.net/sinat_35512245/article/details/54744815)

Java虚拟机规范当中运行时数据为以上六种。



---



#### 3.Java GC在什么时候，对什么东西，做了什么事情

>   介绍GC，关于这个可以看一下几篇文章，对GC执行时刻，算法，过程都解释的很清楚。
>
>   +   [Java GC的那些事—上](http://www.importnew.com/23633.html)
>   +   [Java GC的那些事—下](http://www.importnew.com/23640.html)
>   +   [CMS垃圾收集器介绍](https://blog.csdn.net/mark__zeng/article/details/48751053)

##### 3.1 在什么时候:

1.  新生代有一个`Eden`区和两个`Survivor`区，首先将对象放入`Eden`区，如果空间不足就向其中一个`Survivor`区上放，如果仍然放不下，就会引发一次发生在新生代的`minor GC` ，将存活对象放入另一个`Survivor`区中，然后清空`Eden`和之前那个`Servivor`区的内存，在某次GC过程中，如果发现仍然有放不下对象，那么这些对象就会放入老年代内存里去。
2.  根据上述过程，对方放入老年代内存可知，大对象以及长期存错的对象直接进入老年区。
3.  当每次执行`Minor GC`的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的到小超过了老年区的剩余大小，那么执行一次`Full GC`以尽可能的获取老年区的空间。

##### 3.2 对什么东西:

1.  从`GC Roots`搜索不到，而且经过一次标记清理之后仍没有复活的对象。注意：这里的一次标记。

##### 3.3 做什么事情:

1.   **新生代**：复制清理
2.   **老年代**：标记-清除和标记-压缩算法
3.   **永生代**：存放Java中类和加载类的类加载器本身

##### 3.4 GC Roots有哪些:

1.  虚拟机栈中引用的对象
2.   方法区中静态属性引用的对象，常量引用对象
3.  本地方法栈中JNI引用的对象。（JNI就是常说的Native方法）



---



#### 4.Java中堆栈区别，说说Java内存机制

1.  基本数据类型，变量和对象的引用都是在栈中分配的。
2.  堆内存用来存放有new创建的对象和数组。
3.  类变量（static修饰的变量），程序加载启动时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中。
4.  实例变量，当时用Java关键字`new`的时候，系统在堆中开辟并不一定是连续的空间分配给变量，根据零散的堆内存地址，通过哈希算法换算为一长串数字以表示这个变量在队中的`物理地址`，实例变量的生命周期：当实例变量的引用丢失后，将被GC(垃圾回收机制)列入可回收`名单 `中，但并不是马上就释放堆中内存。注意该`名单`含义：和上述新生代老生代关系。
5.  局部变量：由生命在某方法，或者代码段中，执行到它的时候在栈当中开辟内存空间，当局部变量一旦脱离作用域，内存立即释放。



---



#### 5. wait()和sleep()区别

1.  `wait()`来自`Thread类`，而`sleep()`来自`Object类`
2.  调用`sleep()`方法过程中，线程不会释放对象所，而调用`wait()`方法，线程会释放对象锁
3.  `sleep()`睡眠后不会让出系统资源，但`wait()`让出系统资源，其他进程可调用CPU
4.  `sleep(milliseconds)`需要指定一个睡眠时间，到点自动唤醒



















































