[TOC]



#### 1、部门最高工资

+   `Employee`表中所有员工，每个员工有 Id, salary 和 department Id 信息

```
+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
```

+   `Department`表有公司的所有部门

```
+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
```

+   用 SQL查询语句找出每个部门工资最高的员工。如下，Max在IT部门有最高工资，Henry在Sales部门有最高工资。

```
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
```



#### 2、连续出现的数字

+   编写一个SQL查询，查找至少连续出现三次的所有数字。

```
+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
```

+   例如，给定上面的 `Logs` 表， `1` 是唯一连续出现至少三次的数字。

```
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
```



#### 3、部门前三收入

+   `Employee` 表包含所有员工信息，每个员工有对应的 Id，此外还有一列部门 Id。

```
+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
+----+-------+--------+--------------+
```

+   `Department` 表包含整个公司的部门信息。

```
+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
```

+   用 SQL 查询语句找出每个部门中收入前三的员工，SQL 查询结果如下：

```
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+
```



#### 4、分数排名

+   编写一个 SQL查询 来实现分数排名。如果两个分数相同，则两个分数排名（Rank）应该相同。请注意，平局之后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“漏洞”。

```
+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
```

+   例如，根据给定的上述 `Scores` 表，您的查询应该生成以下报告（按最高分排序）：

```
+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```



#### 5、超过经理收入的员工

+   `Employee` 表包含所有员工，包括他们的经理。每个员工都有一个 Id，此外还有一列对应的经理 Id。

```
+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
```

+   在 `Employee` 表中，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工。在上面的表格中，Joe 是唯一一个收入超过他经理的员工。

```
+----------+
| Employee |
+----------+
| Joe      |
+----------+
```



#### 6、删除重复的邮件

+   编写一个SQL查询来删除`Person`表中所有重复的电子邮件，在重复的邮件中只保留**Id** 最小的邮件。

```
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id是这个表的主键.
```

+   例如，在运行查询之后，上面的 `Person` 表应显示以下几行:

```
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
```

